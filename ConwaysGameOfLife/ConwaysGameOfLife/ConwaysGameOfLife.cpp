#include "framework.h"
#include "ConwaysGameOfLife.h"

#include <vector>
#include <string>
#include <errno.h>

#include <iostream>
#include <fstream>

struct cell
{
    bool isAlive;
    cell* neighbors[8];
};

#pragma region Definitions

#define MAX_PATH_LEN 260
#define CELL_SIZE 10

#define TABLE_LEFT_OFFSET 5
#define TABLE_TOP_OFFSET 50

#define TABLE_WIDTH 64
#define TABLE_HEIGHT 64

#define UPD_RATE_MS 100

#pragma region UI elements IDs

#define ID_STOPBUTTON 10001
#define ID_CLEARBUTTON 10002

#define ID_SAVEBUTTON 10003
#define ID_LOADBUTTON 10004

#define ID_TIMER 1

#pragma endregion

#pragma endregion

#pragma region Declarations

bool isTablePeriodic = true;
bool theGamesOn;

cell table[TABLE_WIDTH][TABLE_HEIGHT];

#pragma region WinAPI stuff

HINSTANCE hInst;
HWND hMainWnd;
HDC mainHdc;

static TCHAR szWindowClass[] = L"does it matter what i write here?"; // apparently no
static TCHAR szTitle[] = L"Conway's Game of Life";

#pragma endregion

int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPreviousInst, LPSTR lpCommandLine, int nCommandShow);
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

void OnLButtonDown(int x, int y);
void UpdTable();

int numOfLivingNeighbors(int index, int jndex);
void changeCell(int i, int j);
void clearTable();

void writeTableToFile(LPWSTR path);
void readTableFromFile(LPWSTR path);

void drawTable();
void drawCellAt(int i, int j);

#pragma endregion

#pragma region The damn WinMain and WndProc functions

int WINAPI WinMain(HINSTANCE hInst,
    HINSTANCE hPreviousInst,
    LPSTR lpCommandLine,
    int nCommandShow) {

    // 1: описываем класс окна (the code partly copied from the function ATOM MyRegisterClass(HINSTANCE hInstance) generated by default)
    WNDCLASSEXW wcex;

    wcex.cbSize = sizeof(WNDCLASSEX);

    wcex.style = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc = WndProc;
    wcex.cbClsExtra = 0;
    wcex.cbWndExtra = 0;
    wcex.hInstance = hInst;
    wcex.hIcon = LoadIconW(hInst, IDI_APPLICATION);
    wcex.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wcex.lpszMenuName = nullptr;
    wcex.lpszClassName = szWindowClass;
    wcex.hIconSm = LoadIcon(wcex.hInstance, IDI_APPLICATION);

    // регистрируем класс
    if (!RegisterClassEx(&wcex)) {
        MessageBox(nullptr,
            L"Не получилось зарегистрировать класс!",
            L"Ошибка", MB_OK);
        return 0;
    }

    hMainWnd = CreateWindow(szWindowClass,               	// имя класса
        szTitle,           		                            // заголовок окна
        WS_OVERLAPPEDWINDOW | WS_VSCROLL,                   // режимы отображения окошка
        CW_USEDEFAULT,             			                // положение окна по оси х (по умолчанию)
        NULL,                      			  		        // позиция окна по оси у (раз х задан по умолчанию, то писать не нужно)
        CW_USEDEFAULT,             			                // ширина окошка (по умолчанию)
        NULL,                      			 		        // высота окна (раз ширина по умолчанию, то писать не нужно)
        NULL,       					                    // дескриптор родительского окошка (у нас нету родителя :( )
        NULL,             				                    // дескриптор пункта меню (у нас его нет)
        hInst, 					                            // дескриптор экземпляра приложения
        NULL);            				                    // ничего не передаём в WM_CREATE

    // 2: создаём окно
    if (!hMainWnd) {
        // в случае некорректного создания окна (неверные параметры и т.п.):
        MessageBox(NULL, L"Не получилось создать окно!", L"Ошибка", MB_OK);
        return NULL; // выходим из приложения
    }

    // 2.5: creating stop button, clear button, save button and load button
    // (CreateWindow == CreateWindowW)

    HWND hStopButtonWnd = CreateWindowW(_T("BUTTON"), _T("Resume/Pause"),
        WS_CHILD | WS_VISIBLE, 5, 5, 110, 30, hMainWnd,
        (HMENU)ID_STOPBUTTON, hInst, NULL);

    HWND hClearButtonWnd = CreateWindowW(_T("BUTTON"), _T("Clear"),
        WS_CHILD | WS_VISIBLE, 120, 5, 110, 30, hMainWnd,
        (HMENU)ID_CLEARBUTTON, hInst, NULL);

    HWND hSaveButtonWnd = CreateWindowW(_T("BUTTON"), _T("Save table"),
        WS_CHILD | WS_VISIBLE, 235, 5, 110, 30, hMainWnd,
        (HMENU)ID_SAVEBUTTON, hInst, NULL);

    HWND hLoadButtonWnd = CreateWindowW(_T("BUTTON"), _T("Load table"),
        WS_CHILD | WS_VISIBLE, 350, 5, 110, 30, hMainWnd,
        (HMENU)ID_LOADBUTTON, hInst, NULL);

    // 3: показываем окно на экране
    ShowWindow(hMainWnd, nCommandShow);
    UpdateWindow(hMainWnd);

    // 3.5: setting up the initial conditions: an empty table and the paused game of life
    for (int i = 0; i < TABLE_WIDTH; i++)
        for (int j = 0; j < TABLE_HEIGHT; j++)
        {
            int neighborIndex = 0;
            for (int di = -1; di <= 1; di++)           
                for (int dj = -1; dj <= 1; dj++)
                    if (di != 0 || dj != 0)
                    {
                        int nI = i + di, nJ = j + dj;

                        if (!isTablePeriodic && (nI < 0 || nJ < 0 || nI >= TABLE_WIDTH || nJ >= TABLE_HEIGHT))
                            continue;

                        table[i][j].neighbors[neighborIndex] = &table[(TABLE_WIDTH + i + di) % TABLE_WIDTH][(TABLE_HEIGHT + j + dj) % TABLE_HEIGHT];
                        neighborIndex++;
                    }
        }

    clearTable();
    theGamesOn = 0;
    mainHdc = GetDC(hMainWnd);

    // 4: организуем цикл обработки сообщений
    MSG msg;

    while (GetMessage(&msg, NULL, NULL, NULL)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_CREATE:
        SetTimer(hWnd, ID_TIMER, UPD_RATE_MS, NULL);
        break;
    case WM_TIMER:
        if (wParam == ID_TIMER && theGamesOn) // checking timer id
            UpdTable();
        break;
    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps);

        EndPaint(hWnd, &ps);

        clearTable();
        drawTable();
    }
    break;
    case WM_LBUTTONDOWN:
    {
        // the user has clicked the mouse left button
        OnLButtonDown(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
    }
    break;
    case WM_COMMAND:
    {
        switch(LOWORD(wParam)) {
        case ID_CLEARBUTTON:
            clearTable();
            break;
        case ID_STOPBUTTON:
            theGamesOn = !theGamesOn;
            break;
        case ID_SAVEBUTTON:
        case ID_LOADBUTTON:
        {
            OPENFILENAME ofn;       // common dialog box structure
            char szFile[MAX_PATH_LEN];       // buffer for file name
            HANDLE hf;              // file handle

            // Initialize OPENFILENAME
            ZeroMemory(&ofn, sizeof(ofn));
            ofn.lStructSize = sizeof(ofn);
            ofn.hwndOwner = hWnd;
            ofn.lpstrFile = (LPWSTR)szFile;
            // Set lpstrFile[0] to '\0' so that GetOpenFileName does not 
            // use the contents of szFile to initialize itself.
            ofn.lpstrFile[0] = '\0';
            ofn.nMaxFile = sizeof(szFile);
            ofn.lpstrFilter = L"All\0*.*\0Text\0*.TXT\0";
            ofn.nFilterIndex = 1;
            ofn.lpstrFileTitle = NULL;
            ofn.nMaxFileTitle = 0;
            ofn.lpstrInitialDir = NULL;
            ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

            // Display the Open dialog box. 

            if (LOWORD(wParam) == ID_SAVEBUTTON)
            {
                if (GetSaveFileName(&ofn) == TRUE)
                {
                    hf = CreateFileW(ofn.lpstrFile,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        (LPSECURITY_ATTRIBUTES)NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE)NULL);

                    writeTableToFile(ofn.lpstrFile);
                }
            }
            else
            {
                if (GetOpenFileName(&ofn) == TRUE)
                {
                    hf = CreateFile(ofn.lpstrFile,   // file to open
                        GENERIC_READ,          // open for reading
                        FILE_SHARE_READ,       // share for reading
                        NULL,                  // default security
                        OPEN_EXISTING,         // existing file only
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, // normal file
                        NULL);                 // no attr. template

                    readTableFromFile(ofn.lpstrFile);
                }
            }
        }
        break;
        default:
            break;
        }
    }
    break;
    case WM_DESTROY:
        KillTimer(hWnd, ID_TIMER);
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

#pragma endregion

#pragma region User input to the table

// if the mouse left button clicked in the table area, changing the clicked cell's color
void OnLButtonDown(int x, int y)
{
    // translating x and y into table indices
    int i = (x - TABLE_LEFT_OFFSET) / CELL_SIZE;
    int j = (y - TABLE_TOP_OFFSET) / CELL_SIZE;

    // checking if the indices are within the table
    if (i < 0 || i >= TABLE_WIDTH || j < 0 || j >= TABLE_HEIGHT)
        return;

    changeCell(i, j);
}

#pragma endregion

#pragma region A couple of functions for the logic of the game

// changes the table to be the next generation
void UpdTable()
{
    // setting up a list of cells to be either killed or born
    std::vector<std::pair<int, int>> cellsToBeChanged;

    // filling the list following the Conway's Game Of Life rules
    for (int i = 0; i < TABLE_WIDTH; i++)
        for (int j = 0; j < TABLE_HEIGHT; j++)
        {
            int num = numOfLivingNeighbors(i, j);
            if ((table[i][j].isAlive && num != 2 && num != 3) || (!table[i][j].isAlive && num == 3))
                cellsToBeChanged.push_back(std::pair<int, int>(i, j));   
        }

    // changing the cells in the list
    for (int i = 0; i < cellsToBeChanged.size(); i++)
        changeCell(cellsToBeChanged[i].first, cellsToBeChanged[i].second);
}

// returns the number of living neighbor cells of the cell at i-j table position
int numOfLivingNeighbors(int index, int jndex)
{
    int num = 0;

    for (int i = 0; i < 8; i++)
        if (table[index][jndex].neighbors[i] && table[index][jndex].neighbors[i]->isAlive)
            num++;

    return num;
}

#pragma endregion

#pragma region A couple of functions to save and load tables from files (could be somewhat improved)

// writes table values into file of the argument path (no table size validation rn)
void writeTableToFile(LPWSTR path)
{
    std::ofstream os(path);

    for (int i = 0; i < TABLE_WIDTH; i++)
        for (int j = 0; j < TABLE_HEIGHT; j++)
            os << table[i][j].isAlive ? '1' : '0';

    os.close();
}

// reads data from file of the argument path into the table (no validation for table size rn)
void readTableFromFile(LPWSTR path)
{
    std::ifstream is(path);

    if (is.fail())
    {
        MessageBox(NULL, L"Не получилось открыть файл для чтения!", L"Ошибка", MB_OK);
    }

    char c;
    for (int i = 0; i < TABLE_WIDTH; i++)
        for (int j = 0; j < TABLE_HEIGHT; j++)
        {
            c = is.get() - '0';
            table[i][j].isAlive = c == 1 ? 1 : 0;
        }

    is.close();

    drawTable();
}

#pragma endregion

#pragma region Drawing functions
// All drawing is synced with the table array's state in memory

// draws all table cells
void drawTable()
{
    for (int i = 0; i < TABLE_WIDTH; i++)
        for (int j = 0; j < TABLE_HEIGHT; j++)
            drawCellAt(i, j);
}

// draws i-j cell
void drawCellAt(int i, int j)
{
    HDC hdc = GetDC(hMainWnd);
    HPEN hBlackPen = CreatePen(PS_SOLID, 1, RGB(0, 0, 0));
    HBRUSH hBlackBrush = CreateSolidBrush(RGB(0, 0, 0)), hWhiteBrush = CreateSolidBrush(RGB(255, 255, 255));
    SelectObject(hdc, hBlackPen);

    //HBRUSH fill = GetPixel(hdc, TABLE_LEFT_OFFSET + i * CELL_SIZE + CELL_SIZE / 2, TABLE_TOP_OFFSET + j * CELL_SIZE + CELL_SIZE / 2) ? hBlackBrush : hWhiteBrush;
    HBRUSH fill = table[i][j].isAlive ? hBlackBrush : hWhiteBrush;

    RECT rc;
    rc.left = TABLE_LEFT_OFFSET + i * CELL_SIZE;
    rc.top = TABLE_TOP_OFFSET + j * CELL_SIZE;
    rc.right = rc.left + CELL_SIZE;
    rc.bottom = rc.top + CELL_SIZE;

    //Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
    FillRect(hdc, &rc, fill);

    DeleteObject(hBlackPen);
    DeleteObject(hBlackBrush);
    DeleteObject(hWhiteBrush);

    ReleaseDC(hMainWnd, hdc);
}

// clears the table area of the main window and the table
void clearTable()
{
    for (int i = 0; i < TABLE_WIDTH; i++)
        for (int j = 0; j < TABLE_HEIGHT; j++)
            table[i][j].isAlive = false;

    HDC hdc = GetDC(hMainWnd);
    HPEN hBlackPen = CreatePen(PS_SOLID, 1, RGB(0, 0, 0));
    HBRUSH hWhiteBrush = CreateSolidBrush(RGB(255, 255, 255));
    SelectObject(hdc, hBlackPen);

    Rectangle(hdc, TABLE_LEFT_OFFSET - 2, TABLE_TOP_OFFSET - 2, TABLE_LEFT_OFFSET + TABLE_WIDTH * CELL_SIZE + 4, TABLE_TOP_OFFSET + TABLE_HEIGHT * CELL_SIZE + 4);

    DeleteObject(hBlackPen);
    DeleteObject(hWhiteBrush);

    ReleaseDC(hMainWnd, hdc);
}

// changes the color of the cell at i-j table position
void changeCell(int i, int j)
{
    table[i][j].isAlive = !table[i][j].isAlive;

    drawCellAt(i, j);
}

#pragma endregion
